# -*- coding: utf-8 -*-
"""tmp_clustering_radius_based.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1webpOxUsckcn18BIFbq5P3hJTxrg6zNZ
"""

import networkx as nx
import matplotlib.pyplot as plt
from geopy.geocoders import Nominatim
from geopy.distance import geodesic

# Define the center node and radius for clustering
radius = 5  # km

# Step 1: Setup Geolocator with Increased Timeout and Caching
class CachedGeolocator:
    def __init__(self, user_agent="geo_clustering"):
        self.geolocator = Nominatim(user_agent=user_agent, timeout=10)
        self.cache = {}

    def geocode(self, address):
        # Check if the result is cached
        if address in self.cache:
            print(f"Using cached result for: {address}")
            return self.cache[address]

        # Otherwise, geocode the address and cache the result
        location = self.geolocator.geocode(address)
        if location:
            self.cache[address] = location
            return location
        return None

geolocator = CachedGeolocator(user_agent="geo_clustering")

# Addresses to geocode
addresses = [
    "Times Square, New York, USA",
    "Empire State Building, New York, USA",
    "Wall Street, New York, USA",
    "Brooklyn Bridge, New York, USA",
    "Central Park, New York, USA",
    "Golden Gate Bridge, San Francisco, USA",
    "Alcatraz Island, San Francisco, USA",
    "Silicon Valley, California, USA",
    "Rockefeller Center, New York, USA",
    "Broadway, New York, USA"
]

# Step 2: Convert Addresses to Coordinates
locations = {}
for address in addresses:
    location = geolocator.geocode(address)
    if location:
        locations[address] = (location.latitude, location.longitude)
    else:
        print(f"Could not find: {address}")

# Step 3: Create the Graph for Nodes within 10 km
G = nx.Graph()

# Step 4: Implement Clustering Algorithm
def cluster_nodes_by_radius(locations, radius):
    clusters = []
    visited = set()

    # Convert the locations to a list of address, coordinates
    locations_list = list(locations.items())

    for center_idx, (center_address, center_coord) in enumerate(locations_list):
        if center_address in visited:
            continue

        # Start a new cluster with the current center node
        cluster = {center_address}
        visited.add(center_address)

        # Check if other nodes are within the radius from the current center
        for other_address, other_coord in locations_list:
            if other_address not in visited:
                distance = geodesic(center_coord, other_coord).km
                if distance <= radius:
                    cluster.add(other_address)
                    visited.add(other_address)

        clusters.append(cluster)

    return clusters

# Get clusters using the algorithm
clusters = cluster_nodes_by_radius(locations, radius)

# Step 5: Build the Graph Based on the Clusters
for cluster in clusters:
    for addr in cluster:
        G.add_node(addr, pos=locations[addr])

# Add edges based on the 10 km distance within the same cluster
for cluster in clusters:
    for addr1 in cluster:
        for addr2 in cluster:
            if addr1 != addr2:
                distance = geodesic(locations[addr1], locations[addr2]).km
                if distance <= radius:
                    G.add_edge(addr1, addr2, weight=distance)

# Step 6: Improved Graph Visualization
plt.figure(figsize=(10, 6))

# Using spring_layout to make the nodes appear closer to each other
pos = nx.spring_layout(G, k=1.8, seed=42)  # k controls the distance between nodes (lower values = nodes closer)

# Draw the graph with labels, smaller nodes, and closer spacing
nx.draw_networkx_nodes(G, pos, node_size=250, node_color='skyblue', alpha=0.7)
nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')
nx.draw_networkx_edges(G, pos, alpha=0.6, width=1.5)

# Edge labels for distances
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels={key: f'{value:.2f} km' for key, value in edge_labels.items()})

# Set title and show the plot
plt.title(f"Clustered Nodes with {radius} km Radius")
plt.axis("off")  # Hide axes for better appearance
plt.show()

# Print clusters
print("Clusters based on 10 km radius:")
for i, cluster in enumerate(clusters, 1):
    print(f"Cluster {i}: {cluster}")